(window.webpackJsonp=window.webpackJsonp||[]).push([[48],{522:function(e,t,a){"use strict";a.r(t);var n=a(42),r=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"metamask项目方给solidity程序员的16个安全建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#metamask项目方给solidity程序员的16个安全建议"}},[e._v("#")]),e._v(" Metamask项目方给Solidity程序员的16个安全建议")]),e._v(" "),a("p",[a("strong",[e._v("原文")]),e._v("："),a("a",{attrs:{href:"https://consensys.net/blog/developers/solidity-best-practices-for-smart-contract-security/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Solidity Best Practices for Smart Contract Security"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("strong",[e._v("原文作者")]),e._v("：Consensys（metamask项目方）")]),e._v(" "),a("p",[a("strong",[e._v("翻译")]),e._v("："),a("a",{attrs:{href:"https://twitter.com/0xAA_Science",target:"_blank",rel:"noopener noreferrer"}},[e._v("0xAA"),a("OutboundLink")],1)]),e._v(" "),a("p",[a("strong",[e._v("Github")]),e._v(": "),a("a",{attrs:{href:""}},[e._v("WTFSolidity")]),e._v("https://github.com/AmazingAng/WTFSolidity")]),e._v(" "),a("blockquote",[a("p",[e._v("写在前面：")]),e._v(" "),a("p",[e._v("这是Metamask项目方（Consensys）在2020年8月写的一篇博客，关于智能合约安全，其中给了Solidity程序员16条安全建议，并包含代码样例。")]),e._v(" "),a("p",[e._v("这篇文章写于一年半前，那时候solidity版本才到0.5,现在已经是0.8了，很多函数都不同。但很多建议至今仍然适用，读完对我帮助很大。我在网上没找到中文翻译，就简单翻译了一下，并标明了版本差异可能导致的问题，供中文开发者学习。")]),e._v(" "),a("p",[e._v("这篇文章的安全理念也融入到WTF Solidity极简入门教程中。")]),e._v(" "),a("p",[e._v("By 0xAA")])]),e._v(" "),a("p",[e._v("如果您已经牢记智能合约的安全理念并且正在处理"),a("code",[e._v("EVM")]),e._v("的特性，那么是时候考虑一​​些特定于"),a("code",[e._v("Solidity")]),e._v("编程语言的安全模式了。在本综述中，我们将重点关注"),a("code",[e._v("Solidity")]),e._v("的安全开发建议，这些建议也可能对用其他语言开发智能合约具有指导意义。")]),e._v(" "),a("p",[e._v("好了，让我们开始吧。")]),e._v(" "),a("h2",{attrs:{id:"_1-正确使用-assert-require-revert"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-正确使用-assert-require-revert"}},[e._v("#")]),e._v(" 1. 正确使用 "),a("code",[e._v("assert(), require(), revert()")])]),e._v(" "),a("p",[e._v("便利函数 "),a("code",[e._v("assert")]),e._v(" 和 "),a("code",[e._v("require")]),e._v(" 可用于检查条件，如果条件不满足则抛出异常。")]),e._v(" "),a("p",[a("code",[e._v("assert")]),e._v(" 函数只能用于测试内部错误和检查不变量。")]),e._v(" "),a("p",[e._v("应该使用 "),a("code",[e._v("require")]),e._v(" 函数来确保满足有效条件，例如输入或合约状态变量，或者验证来自外部合约调用的返回值。 （"),a("code",[e._v("0xAA注: solidity在0.8.4版本引入自定义error功能，所以这个版本之前用require，之后用revert-error来确保满足有效条件")]),e._v("）")]),e._v(" "),a("p",[e._v("遵循这种范式可以让形式化分析工具来验证无效操作码永远不会被运行：这意味着代码中没有不变量被违反并且被形式化验证。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('pragma solidity ^0.5.0;\n\ncontract Sharer {\n    function sendHalf(address payable addr) public payable returns (uint balance) {\n        require(msg.value % 2 == 0, "偶数required."); //Require() 可以加一个自定义消息\n        uint balanceBeforeTransfer = address(this).balance;\n        (bool success, ) = addr.call.value(msg.value / 2)("");\n        require(success);\n        // 如果success为false，就revert。下面的总是成立。\n        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2); // used for internal error checking\n        return address(this).balance;\n    }\n}\n')])])]),a("h2",{attrs:{id:"_2-modifier仅用于检查"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-modifier仅用于检查"}},[e._v("#")]),e._v(" 2. "),a("code",[e._v("modifier")]),e._v("仅用于检查")]),e._v(" "),a("p",[e._v("修饰符（"),a("code",[e._v("modifier")]),e._v("）内的代码通常在函数体之前执行，因此任何状态更改或外部调用都会违反 "),a("code",[e._v("Checks-Effects-Interactions")]),e._v("模式。此外，开发人员也可能不会注意到这些语句，因为修饰符的代码可能远离函数声明。例如，修饰符的外部调用可能导致重入攻击：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract Registry {\n    address owner;\n\n    function isVoter(address _addr) external returns(bool) {\n        // Code\n    }\n}\n\ncontract Election {\n    Registry registry;\n\n    modifier isEligible(address _addr) {\n        require(registry.isVoter(_addr));\n        _;\n    }\n\n    function vote() isEligible(msg.sender) public {\n        // Code\n    }\n}\n")])])]),a("p",[e._v("在这种情况下，"),a("code",[e._v("Registry")]),e._v("合约可以通过调用"),a("code",[e._v("isVoter()")]),e._v("中的"),a("code",[e._v("Election.vote()")]),e._v(" 进行重入攻击。")]),e._v(" "),a("p",[e._v("注意：使用"),a("code",[e._v("modifier")]),e._v("替换多个函数中的重复条件检查，例如 "),a("code",[e._v("isOwner()")]),e._v("，否则在函数内部使用"),a("code",[e._v("require")]),e._v("或"),a("code",[e._v("revert")]),e._v("。这使您的智能合约代码更具可读性和更易于审计。")]),e._v(" "),a("h2",{attrs:{id:"_3-注意整数除法的舍入"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-注意整数除法的舍入"}},[e._v("#")]),e._v(" 3. 注意整数除法的舍入")]),e._v(" "),a("p",[e._v("所有整数除法都向下舍入到最接近的整数。如果您需要更高的精度，请考虑使用乘数，或同时存储分子和分母。")]),e._v(" "),a("p",[e._v("（将来，"),a("code",[e._v("Solidity")]),e._v(" 会有浮点类型，这会让这更容易。）")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\nuint x = 5 / 2; // Result is 2, all integer divison rounds DOWN to the nearest integer\n")])])]),a("p",[e._v("使用乘数可以防止四舍五入，在将来使用 x 时需要考虑这个乘数：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// good\nuint multiplier = 10;\nuint x = (5 * multiplier) / 2;\n")])])]),a("p",[e._v("存储分子和分母意味着你可以计算 numerator/denominator 链下的结果：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// good\nuint numerator = 5;\nuint denominator = 2;\n")])])]),a("h3",{attrs:{id:"_4-注意抽象合约abstract和接口interface之间的权衡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-注意抽象合约abstract和接口interface之间的权衡"}},[e._v("#")]),e._v(" 4. 注意抽象合约"),a("code",[e._v("abstract")]),e._v("和接口"),a("code",[e._v("interface")]),e._v("之间的权衡")]),e._v(" "),a("p",[e._v("接口和抽象合约都为智能合约提供了一种可定制和可重用的方法。"),a("code",[e._v("Solidity 0.4.11")]),e._v("中引入的接口类似于抽象合约，但不能实现任何功能。接口也有限制，例如不能访问存储或从其他接口继承，这通常使抽象合约更实用。虽然，接口对于在实现之前设计合约肯定有用。此外，重要的是要记住，如果合约继承自抽象合约，它必须通过覆盖实现所有未实现的功能，否则它也将是抽象的。")]),e._v(" "),a("h2",{attrs:{id:"_5-fallback-function-后备函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-fallback-function-后备函数"}},[e._v("#")]),e._v(" 5. Fallback function 后备函数")]),e._v(" "),a("blockquote",[a("p",[e._v("0xAA注："),a("code",[e._v("Solidity 0.5.0")]),e._v("时还没有"),a("code",[e._v("receive")]),e._v("函数且"),a("code",[e._v("fallback")]),e._v("函数当时也直接声明为"),a("code",[e._v("function()")]),e._v("。关于最新版本的"),a("code",[e._v("fallback")]),e._v("函数教程，请看"),a("a",{attrs:{href:"https://mirror.xyz/ninjak.eth/EroVZqHW1lfJFai3umiu4tb9r1ZbDVPOYC-puaZklAw",target:"_blank",rel:"noopener noreferrer"}},[e._v("链接"),a("OutboundLink")],1)])]),e._v(" "),a("h3",{attrs:{id:"保持fallback-function简单"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#保持fallback-function简单"}},[e._v("#")]),e._v(" 保持fallback function简单")]),e._v(" "),a("p",[e._v("当合约被发送一个没有参数的消息（或者没有函数匹配）或，"),a("code",[e._v("fallback function")]),e._v("会被调用。当被"),a("code",[e._v(".send()")]),e._v("或"),a("code",[e._v(".transfer")]),e._v("触发时，"),a("code",[e._v("fallback function")]),e._v("只能访问"),a("code",[e._v("2300 gas")]),e._v("。如果您希望能够从"),a("code",[e._v("send()")]),e._v("或"),a("code",[e._v(".transfer()")]),e._v("接收"),a("code",[e._v("ETH")]),e._v("，那么您在后备函数中最多可以做的就是记录一个事件。如果需要计算更多"),a("code",[e._v("gas")]),e._v("，请使用适当的函数。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\nfunction() payable { balances[msg.sender] += msg.value; }\n\n// good\nfunction deposit() payable external { balances[msg.sender] += msg.value; }\n\nfunction() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); }\n")])])]),a("h3",{attrs:{id:"检查回退函数中的数据长度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#检查回退函数中的数据长度"}},[e._v("#")]),e._v(" 检查回退函数中的数据长度")]),e._v(" "),a("p",[e._v("由于 "),a("code",[e._v("fallback function")]),e._v(" 不仅在普通以太传输（没有"),a("code",[e._v("msg.data")]),e._v("）时调用，并且也在没有其他函数匹配时调用，如果后备函数仅用于记录接收到的"),a("code",[e._v("ETH")]),e._v("，则应检查数据是否为空。否则，如果你的合约使用不正确，调用了不存在的函数，调用者将不会注意到。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\nfunction() payable { emit LogDepositReceived(msg.sender); }\n\n// good\nfunction() payable { require(msg.data.length == 0); emit LogDepositReceived(msg.sender); }\n")])])]),a("h2",{attrs:{id:"_6-显式标记应付函数和状态变量"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-显式标记应付函数和状态变量"}},[e._v("#")]),e._v(" 6. 显式标记应付函数和状态变量")]),e._v(" "),a("p",[e._v("从 "),a("code",[e._v("Solidity 0.4.0")]),e._v("开始，每个接收以太币的函数都必须使用 "),a("code",[e._v("payable")]),e._v("修饰符，否则如果交易有"),a("code",[e._v("msg.value > 0")]),e._v(" 将被"),a("code",[e._v("revert")]),e._v("。")]),e._v(" "),a("p",[a("strong",[e._v("注意")]),e._v("：可能不明显的事情： "),a("code",[e._v("payable")]),e._v(" 修饰符仅适用于来自 "),a("code",[e._v("external")]),e._v(" 合约的调用。如果我在同一个合约的"),a("code",[e._v("payable")]),e._v("函数中调用了一个非"),a("code",[e._v("payable")]),e._v("函数，这个非"),a("code",[e._v("payable")]),e._v("函数不会失败，尽管 "),a("code",[e._v("msg.value")]),e._v("不为零。")]),e._v(" "),a("h2",{attrs:{id:"_7-显式标记函数和状态变量的可见性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-显式标记函数和状态变量的可见性"}},[e._v("#")]),e._v(" 7. 显式标记函数和状态变量的可见性")]),e._v(" "),a("p",[e._v("明确标记函数和状态变量的可见性。函数可以指定为 "),a("code",[e._v("external")]),e._v("， "),a("code",[e._v("public")]),e._v("，"),a("code",[e._v("internal")]),e._v("或"),a("code",[e._v("private")]),e._v("。请理解它们之间的差异，例如，"),a("code",[e._v("external")]),e._v("可能足以代替 "),a("code",[e._v("public")]),e._v("。而对于状态变量，"),a("code",[e._v("external")]),e._v("是不用的。明确标记可见性将更容易捕捉关于谁可以调用函数或访问变量的错误。")]),e._v(" "),a("ol",[a("li",[a("p",[a("code",[e._v("External")]),e._v("函数是合约接口的一部分。"),a("code",[e._v("external")]),e._v("函数"),a("code",[e._v("f")]),e._v("不能在内部调用（即"),a("code",[e._v("f()")]),e._v(" 不工作，但 "),a("code",[e._v("this.f()")]),e._v(" 工作）。外部函数在接收大量数据时效率更高。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("Public")]),e._v("函数是合约接口的一部分，既可以在内部调用，也可以通过消息调用。对于公共状态变量，会生成一个自动 "),a("code",[e._v("getter")]),e._v(" 函数。")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("Internal")]),e._v(" 函数和状态变量只能在内部访问，不使用"),a("code",[e._v("this")]),e._v(".")])]),e._v(" "),a("li",[a("p",[a("code",[e._v("Private")]),e._v(" 函数和状态变量仅对定义它们的合约可见，而在派生合约中不可见。 "),a("strong",[e._v("注意")]),e._v("：合约内的所有内容对区块链外部的所有观察者都是可见的，甚至是 "),a("code",[e._v("Private")]),e._v(" 变量。")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\nuint x; // the default is internal for state variables, but it should be made explicit\nfunction buy() { // the default is public\n    // public code\n}\n\n// good\nuint private y;\nfunction buy() external {\n    // only callable externally or using this.buy()\n}\n\nfunction utility() public {\n    // callable externally, as well as internally: changing this code requires thinking about both cases.\n}\n\nfunction internalAction() internal {\n    // internal code\n}\n")])])]),a("h2",{attrs:{id:"_8-将编译指示锁定到特定的编译器版本"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-将编译指示锁定到特定的编译器版本"}},[e._v("#")]),e._v(" 8. 将编译指示锁定到特定的编译器版本")]),e._v(" "),a("p",[e._v("合约应该使用与它们经过最多测试的相同编译器版本和标志来部署。锁定 pragma 有助于确保合约不会被意外部署，例如使用可能具有更高风险未发现错误的最新编译器。合约也可能由其他人部署，并且 "),a("code",[e._v("pragma")]),e._v(" 指示原作者预期的编译器版本。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\npragma solidity ^0.4.4;\n\n\n// good\npragma solidity 0.4.4;\n")])])]),a("p",[a("strong",[e._v("注意")]),e._v("：浮动 "),a("code",[e._v("pragma")]),e._v(" 版本（即 "),a("code",[e._v("^0.4.25")]),e._v("）可以用"),a("code",[e._v("0.4.26-nightly.2018.9.25")]),e._v("编译，但不应使用"),a("code",[e._v("nightly")]),e._v("版本来编译生产代码。")]),e._v(" "),a("p",[a("strong",[e._v("警告")]),e._v("：当合约打算供其他开发人员使用时，可以允许 "),a("code",[e._v("Pragma")]),e._v(" 语句浮动，例如库或 "),a("code",[e._v("EthPM")]),e._v(" 包中的合约。否则，开发人员需要手动更新编译指示才能在本地编译。")]),e._v(" "),a("h2",{attrs:{id:"_9-使用事件来监控合约活动"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-使用事件来监控合约活动"}},[e._v("#")]),e._v(" 9. 使用事件来监控合约活动")]),e._v(" "),a("p",[e._v("有一种方法可以在部署后监控合约的活动是很有用的。实现这一点的一种方法是查看合约的所有交易，但这可能还不够，因为合约之间的消息调用不会记录在区块链中。此外，它只显示输入参数，而不是对状态进行的实际更改。事件也可用于触发用户界面中的功能。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract Charity {\n    mapping(address => uint) balances;\n\n    function donate() payable public {\n        balances[msg.sender] += msg.value;\n    }\n}\n\ncontract Game {\n    function buyCoins() payable public {\n        // 5% goes to charity\n        charity.donate.value(msg.value / 20)();\n    }\n}\n")])])]),a("p",[e._v("在这里， "),a("code",[e._v("Game")]),e._v(" 合约将内部调用 "),a("code",[e._v("Charity.donate()")]),e._v(". 该交易不会出现在"),a("code",[e._v("Charity")]),e._v(" 的外部交易列表中，而只在内部交易中可见。")]),e._v(" "),a("p",[e._v("事件是记录合约中发生的事情的便捷方式。发出的事件与其他合约数据一起留在区块链中，可供将来审计。这是对上述示例的改进，使用事件来提供慈善机构的捐赠历史。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract Charity {\n    // define event\n    event LogDonate(uint _amount);\n\n    mapping(address => uint) balances;\n\n    function donate() payable public {\n        balances[msg.sender] += msg.value;\n        // emit event\n        emit LogDonate(msg.value);\n    }\n}\n\ncontract Game {\n    function buyCoins() payable public {\n        // 5% goes to charity\n        charity.donate.value(msg.value / 20)();\n    }\n}\n")])])]),a("p",[e._v("在这里，无论是否直接通过合约的所有交易都 "),a("code",[e._v("Charity")]),e._v(" 将与捐赠的金额一起显示在该合约的事件列表中。")]),e._v(" "),a("p",[a("strong",[e._v("注意")]),e._v("：优先使用更新的 Solidity 结构。首选结构/别名，例如 "),a("code",[e._v("selfdestruct")]),e._v(" (而不是  "),a("code",[e._v("suicide")]),e._v(") 和 "),a("code",[e._v("keccak256")]),e._v(" (而不是  "),a("code",[e._v("sha3")]),e._v(")。类似的模式 "),a("code",[e._v("require(msg.sender.send(1 ether))")]),e._v(" 也可以简化为使用 "),a("code",[e._v("transfer()")]),e._v("，如 "),a("code",[e._v("msg.sender.transfer(1 ether)")]),e._v(". 查看 "),a("code",[e._v("Solidity")]),e._v(" 更改日志 以了解更多类似更改。")]),e._v(" "),a("h2",{attrs:{id:"_10-请注意-内置-函数可能会被隐藏"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-请注意-内置-函数可能会被隐藏"}},[e._v("#")]),e._v(" 10. 请注意，“内置”函数可能会被隐藏")]),e._v(" "),a("p",[e._v("目前可以 在 "),a("code",[e._v("Solidity")]),e._v(" 中隐藏内置的全局变量。这允许合约覆盖内置插件的功能，例如 "),a("code",[e._v("msg")]),e._v(" 和 "),a("code",[e._v("revert()")]),e._v("。尽管这是有意为之，但它可能会误导合约用户对合约的真实行为。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract PretendingToRevert {\n    function revert() internal constant {}\n}\n\ncontract ExampleContract is PretendingToRevert {\n    function somethingBad() public {\n        revert();\n    }\n}\n")])])]),a("p",[e._v("合约用户（和审计员）应该了解他们打算使用的任何应用程序的完整智能合约源代码。")]),e._v(" "),a("h2",{attrs:{id:"_11-避免使用-tx-origin"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-避免使用-tx-origin"}},[e._v("#")]),e._v(" 11. 避免使用 tx.origin")]),e._v(" "),a("p",[e._v("永远不要 tx.origin 用于授权，另一个合约可以有一个方法来调用你的合约（例如，用户有一些资金）并且你的合约将授权该交易，因为你的地址位于"),a("code",[e._v("tx.origin")]),e._v(".")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('contract MyContract {\n\n    address owner;\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        (bool success, ) = receiver.call.value(amount)("");\n        require(success);\n    }\n\n}\n\ncontract AttackingContract {\n\n    MyContract myContract;\n    address attacker;\n\n    function AttackingContract(address myContractAddress) public {\n        myContract = MyContract(myContractAddress);\n        attacker = msg.sender;\n    }\n\n    function() public {\n        myContract.sendTo(attacker, msg.sender.balance);\n    }\n\n}\n')])])]),a("p",[e._v("您应该使用 "),a("code",[e._v("msg.sender")]),e._v(" 授权（如果另一个合约调用您的合约 "),a("code",[e._v("msg.sender")]),e._v(" 将是该合约的地址，而不是调用该合约的用户的地址）。")]),e._v(" "),a("p",[a("strong",[e._v("警告")]),e._v("：除了授权问题外， "),a("code",[e._v("tx.origin")]),e._v(" 将来有可能从以太坊协议中删除，因此使用的代码 "),a("code",[e._v("tx.origin")]),e._v(" 将与未来版本不兼容. Vitalik：'不要假设 "),a("code",[e._v("tx.origin")]),e._v(" 将继续存在。")]),e._v(" "),a("p",[e._v("还值得一提的是，通过使用 "),a("code",[e._v("tx.origin")]),e._v(" 您会限制合约之间的互操作性，因为使用 "),a("code",[e._v("tx.origin")]),e._v(" 的合约不能被另一个合约使用，因为合约不能是 "),a("code",[e._v("tx.origin.")])]),e._v(" "),a("h2",{attrs:{id:"_12-时间戳依赖"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-时间戳依赖"}},[e._v("#")]),e._v(" 12. 时间戳依赖")]),e._v(" "),a("p",[e._v("使用时间戳执行合约中的关键功能时，有三个主要考虑因素，尤其是当操作涉及资金转移时。")]),e._v(" "),a("h3",{attrs:{id:"时间戳操作"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#时间戳操作"}},[e._v("#")]),e._v(" 时间戳操作")]),e._v(" "),a("p",[e._v("请注意，区块的时间戳可以由矿工操纵。考虑这个合约：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("uint256 constant private salt =  block.timestamp;\n\nfunction random(uint Max) constant private returns (uint256 result){\n    //get the best seed for randomness\n    uint256 x = salt * 100/Max;\n    uint256 y = salt * block.number/(salt % 5) ;\n    uint256 seed = block.number/3 + (salt % 300) + Last_Payout + y;\n    uint256 h = uint256(block.blockhash(seed));\n\n    return uint256((h / x)) % Max + 1; //random number between 1 and Max\n}\n")])])]),a("p",[e._v("当合约使用时间戳播种一个随机数时，矿工实际上可以在区块被验证后的 15 秒内发布一个时间戳，从而有效地允许矿工预先计算一个更有利于他们中奖机会的选项。时间戳不是随机的，不应在该上下文中使用。")]),e._v(" "),a("h2",{attrs:{id:"_13-15秒规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-15秒规则"}},[e._v("#")]),e._v(" 13. 15秒规则")]),e._v(" "),a("p",[e._v("黄皮书 （Ethereum 的参考规范）没有规定多少块可以在时间上漂移的限制，但它确实规定每个时间戳应该大于其父时间戳。流行的以太坊协议实现 "),a("code",[e._v("Geth")]),e._v("和"),a("code",[e._v("Parity")]),e._v("都拒绝未来时间戳超过 15 秒的块。因此，评估时间戳使用的一个好的经验法则是：如果您的时间相关事件的规模可以变化 15 秒并保持完整性，那么可以使用"),a("code",[e._v("block.timestamp")]),e._v(".")]),e._v(" "),a("h3",{attrs:{id:"避免-block-number-用作时间戳"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#避免-block-number-用作时间戳"}},[e._v("#")]),e._v(" 避免 block.number 用作时间戳")]),e._v(" "),a("p",[e._v("可以使用 "),a("code",[e._v("block.number")]),e._v(" 属性和 平均块时间来估计时间增量，但这不是未来的证据，因为出块时间可能会改变（例如 分叉重组 和 难度炸弹）。但在只持续几天的销售中，15秒规则允许人们获得更可靠的时间估计。")]),e._v(" "),a("h2",{attrs:{id:"_14-多重继承注意事项"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-多重继承注意事项"}},[e._v("#")]),e._v(" 14. 多重继承注意事项")]),e._v(" "),a("p",[e._v("在 Solidity 中使用多重继承时，了解编译器如何构成继承图非常重要。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract Final {\n    uint public a;\n    function Final(uint f) public {\n        a = f;\n    }\n}\n\ncontract B is Final {\n    int public fee;\n\n    function B(uint f) Final(f) public {\n    }\n    function setFee() public {\n        fee = 3;\n    }\n}\n\ncontract C is Final {\n    int public fee;\n\n    function C(uint f) Final(f) public {\n    }\n    function setFee() public {\n        fee = 5;\n    }\n}\n\ncontract A is B, C {\n  function A() public B(3) C(5) {\n      setFee();\n  }\n}\n")])])]),a("p",[e._v("部署合约时，编译器将从右到左线性化继承（在关键字"),a("code",[e._v("is")]),e._v("之后 ，父项从最基类到最派生列出）。这是合约 "),a("code",[e._v("A")]),e._v(" 的线性化：")]),e._v(" "),a("p",[a("code",[e._v("Final <- B <- C <- A")])]),e._v(" "),a("p",[e._v("线性化的结果将产生 "),a("code",[e._v("fee = 5")]),e._v(" 的值，因为 "),a("code",[e._v("C")]),e._v(" 是最接近衍生的合约。这似乎很明显，但想象一下 "),a("code",[e._v("C")]),e._v(" 能够隐藏关键函数、重新排序布尔子句并导致开发人员编写可利用的合约的场景。静态分析目前不会引发被遮盖的函数的问题，因此必须手动检查。")]),e._v(" "),a("p",[e._v("为了帮助做出贡献，"),a("code",[e._v("Solidity")]),e._v(" 的 "),a("code",[e._v("Github")]),e._v(" 有一个包含所有继承相关问题的"),a("a",{attrs:{href:"https://github.com/ethereum/solidity/projects/9#card-8027020",target:"_blank",rel:"noopener noreferrer"}},[e._v("项目"),a("OutboundLink")],1),e._v("。")]),e._v(" "),a("h2",{attrs:{id:"_15-使用接口类型而不是地址来保证类型安全"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-使用接口类型而不是地址来保证类型安全"}},[e._v("#")]),e._v(" 15. 使用接口类型而不是地址来保证类型安全")]),e._v(" "),a("p",[e._v("当函数将合约地址作为参数时，最好传递接口或合约类型而不是  纯"),a("code",[e._v("address")]),e._v("。因为如果函数在源代码的其他地方被调用，编译器将提供额外的类型安全保证。")]),e._v(" "),a("p",[e._v("在这里，我们看到了两种选择：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract Validator {\n    function validate(uint) external returns(bool);\n}\n\ncontract TypeSafeAuction {\n    // good\n    function validateBet(Validator _validator, uint _value) internal returns(bool) {\n        bool valid = _validator.validate(_value);\n        return valid;\n    }\n}\n\ncontract TypeUnsafeAuction {\n    // bad\n    function validateBet(address _addr, uint _value) internal returns(bool) {\n        Validator validator = Validator(_addr);\n        bool valid = validator.validate(_value);\n        return valid;\n    }\n}\n")])])]),a("p",[e._v("可以从下面示例中看出使用"),a("code",[e._v("TypeSafeAuction")]),e._v("合约的好处 。如果 "),a("code",[e._v("validateBet()")]),e._v(" 使用 "),a("code",[e._v("address")]),e._v(" 参数或合约类型而不是"),a("code",[e._v("Validator")]),e._v("合约类型，编译器将抛出此错误：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract NonValidator{}\n\ncontract Auction is TypeSafeAuction {\n    NonValidator nonValidator;\n\n    function bet(uint _value) {\n        bool valid = validateBet(nonValidator, _value); // TypeError: Invalid type for argument in function call.\n                                                        // Invalid implicit conversion from contract NonValidator\n                                                        // to contract Validator requested.\n    }\n}\n")])])]),a("h2",{attrs:{id:"_16-避免-extcodesize-用于检查外部拥有的帐户"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-避免-extcodesize-用于检查外部拥有的帐户"}},[e._v("#")]),e._v(" 16. 避免 "),a("code",[e._v("extcodesize")]),e._v(" 用于检查外部拥有的帐户")]),e._v(" "),a("p",[e._v("以下修饰符（或类似的检查）通常用于验证调用是来自外部拥有的账户（"),a("code",[e._v("EOA")]),e._v("）还是合约账户：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("// bad\nmodifier isNotContract(address _a) {\n  uint size;\n  assembly {\n    size := extcodesize(_a)\n  }\n    require(size == 0);\n     _;\n}\n")])])]),a("p",[e._v("这个想法很简单：如果一个地址包含代码，它就不是一个 "),a("code",[e._v("EOA")]),e._v("，而是一个合约账户。但是，合约在构建期间没有可用的源代码。这意味着在构造函数运行时，它可以调用其他合约，但 "),a("code",[e._v("extcodesize")]),e._v(" 在它的地址返回零。下面是一个最小的例子，展示了如何绕过这个检查：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("contract OnlyForEOA {    \n    uint public flag;\n\n    // bad\n    modifier isNotContract(address _a){\n        uint len;\n        assembly { len := extcodesize(_a) }\n        require(len == 0);\n        _;\n    }\n\n    function setFlag(uint i) public isNotContract(msg.sender){\n        flag = i;\n    }\n}\n\ncontract FakeEOA {\n    constructor(address _a) public {\n        OnlyForEOA c = OnlyForEOA(_a);\n        c.setFlag(1);\n    }\n}\n")])])]),a("p",[e._v("因为可以预先计算合约地址，所以如果它检查一个在 "),a("code",[e._v("block n")]),e._v(" 处为空，但在"),a("code",[e._v("block n")]),e._v("之后被部署的合约，依然会失败。")]),e._v(" "),a("p",[a("strong",[e._v("警告")]),e._v("：这个问题很微妙。如果您的目标是阻止其他合约调用您的合约，那么 "),a("code",[e._v("extcodesize")]),e._v(" 检查可能就足够了。另一种方法是检查 的值 ("),a("code",[e._v("tx.origin == msg.sender")]),e._v(")`，尽管这也有缺点。")]),e._v(" "),a("p",[e._v("在其他情况下， "),a("code",[e._v("extcodesize")]),e._v(" 可能会为您服务。在这里描述所有这些超出了范围。了解 "),a("code",[e._v("EVM")]),e._v(" 的基本行为并使用您的判断。")])])}),[],!1,null,null,null);t.default=r.exports}}]);