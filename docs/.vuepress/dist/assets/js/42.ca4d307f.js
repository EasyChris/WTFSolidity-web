(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{493:function(t,s,e){"use strict";e.r(s);var a=e(42),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"solidity极简入门-11-构造函数和修饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#solidity极简入门-11-构造函数和修饰器"}},[t._v("#")]),t._v(" Solidity极简入门: 11. 构造函数和修饰器")]),t._v(" "),e("p",[t._v("我最近在重新学solidity，巩固一下细节，也写一个“Solidity极简入门”，供小白们使用（编程大佬可以另找教程），每周更新1-3讲。")]),t._v(" "),e("p",[t._v("欢迎关注我的推特："),e("a",{attrs:{href:"https://twitter.com/0xAA_Science",target:"_blank",rel:"noopener noreferrer"}},[t._v("@0xAA_Science"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("WTF技术社群discord，内有加微信群方法："),e("a",{attrs:{href:"https://discord.gg/5akcruXrsk",target:"_blank",rel:"noopener noreferrer"}},[t._v("链接"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("所有代码和教程开源在github（1024个star发课程认证，2048个star发社群NFT）: "),e("a",{attrs:{href:"https://github.com/AmazingAng/WTFSolidity",target:"_blank",rel:"noopener noreferrer"}},[t._v("github.com/AmazingAng/WTFSolidity"),e("OutboundLink")],1)]),t._v(" "),e("hr"),t._v(" "),e("p",[t._v("这一讲，我们将用合约权限控制（"),e("code",[t._v("Ownable")]),t._v("）的例子介绍"),e("code",[t._v("solidity")]),t._v("语言中构造函数（"),e("code",[t._v("constructor")]),t._v("）和独有的修饰器（"),e("code",[t._v("modifier")]),t._v("）。")]),t._v(" "),e("h2",{attrs:{id:"构造函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#构造函数"}},[t._v("#")]),t._v(" 构造函数")]),t._v(" "),e("p",[t._v("构造函数（"),e("code",[t._v("constructor")]),t._v("）是一种特殊的函数，每个合约可以定义一个，并在部署合约的时候自动运行一次。它可以用来初始化合约的一些参数，例如初始化合约的"),e("code",[t._v("owner")]),t._v("地址：")]),t._v(" "),e("div",{staticClass:"language-solidity extra-class"},[e("pre",{pre:!0,attrs:{class:"language-solidity"}},[e("code",[t._v("   "),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("address")]),t._v(" owner"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义owner变量")]),t._v("\n\n   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 构造函数")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("constructor")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      owner "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" msg"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sender"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 在部署合约的时候，将owner设置为部署者的地址")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[e("strong",[t._v("注意")]),t._v("⚠️：构造函数在不同的solidity版本中的语法并不一致，在Solidity 0.4.22之前，构造函数不使用 "),e("code",[t._v("constructor")]),t._v(" 而是使用与合约名同名的函数作为构造函数而使用，由于这种旧写法容易使开发者在书写时发生疏漏（例如合约名叫 "),e("code",[t._v("Parents")]),t._v("，构造函数名写成 "),e("code",[t._v("parents")]),t._v("），使得构造函数变成普通函数，引发漏洞，所以0.4.22版本及之后，采用了全新的 "),e("code",[t._v("constructor")]),t._v(" 写法。")]),t._v(" "),e("p",[t._v("构造函数的旧写法代码示例：")]),t._v(" "),e("div",{staticClass:"language-solidity extra-class"},[e("pre",{pre:!0,attrs:{class:"language-solidity"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("pragma")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("solidity")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v("0.4")]),e("span",{pre:!0,attrs:{class:"token number"}},[t._v(".21")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("contract")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Parents")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 与合约名Parents同名的函数就是构造函数")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" Parents "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("h2",{attrs:{id:"修饰器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#修饰器"}},[t._v("#")]),t._v(" 修饰器")]),t._v(" "),e("p",[t._v("修饰器（"),e("code",[t._v("modifier")]),t._v("）是"),e("code",[t._v("solidity")]),t._v("特有的语法，类似于面向对象编程中的"),e("code",[t._v("decorator")]),t._v("，声明函数拥有的特性，并减少代码冗余。它就像钢铁侠的智能盔甲，穿上它的函数会带有某些特定的行为。"),e("code",[t._v("modifier")]),t._v("的主要使用场景是运行函数前的检查，例如地址，变量，余额等。")]),t._v(" "),e("p",[e("img",{attrs:{src:"https://images.mirror-media.xyz/publication-images/nVwXsOVmrYu8rqvKKPMpg.jpg?height=630&width=1200",alt:"钢铁侠的modifier"}})]),t._v(" "),e("p",[t._v("我们来定义一个叫做onlyOwner的modifier：")]),t._v(" "),e("div",{staticClass:"language-solidity extra-class"},[e("pre",{pre:!0,attrs:{class:"language-solidity"}},[e("code",[t._v("   "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 定义modifier")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("modifier")]),t._v(" onlyOwner "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("require")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("msg"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("sender "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" owner"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 检查调用者是否为owner地址")]),t._v("\n      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("_")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 如果是的话，继续运行函数主体；否则报错并revert交易")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("代有"),e("code",[t._v("onlyOwner")]),t._v("修饰符的函数只能被"),e("code",[t._v("owner")]),t._v("地址调用，比如下面这个例子：")]),t._v(" "),e("div",{staticClass:"language-solidity extra-class"},[e("pre",{pre:!0,attrs:{class:"language-solidity"}},[e("code",[t._v("   "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[t._v("changeOwner")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),e("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("address")]),t._v(" _newOwner"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("external")]),t._v(" onlyOwner"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n      owner "),e("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" _newOwner"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),e("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 只有owner地址运行这个函数，并改变owner")]),t._v("\n   "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])])]),e("p",[t._v("我们定义了一个"),e("code",[t._v("changeOwner")]),t._v("函数，运行他可以改变合约的"),e("code",[t._v("owner")]),t._v("，但是由于"),e("code",[t._v("onlyOwner")]),t._v("修饰符的存在，只有原先的"),e("code",[t._v("owner")]),t._v("可以调用，别人调用就会报错。这也是最常用的控制智能合约权限的方法。")]),t._v(" "),e("h3",{attrs:{id:"oppenzepplin的ownable标准实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#oppenzepplin的ownable标准实现"}},[t._v("#")]),t._v(" OppenZepplin的Ownable标准实现：")]),t._v(" "),e("p",[e("code",[t._v("OppenZepplin")]),t._v("是一个维护"),e("code",[t._v("solidity")]),t._v("标准化代码库的组织，他的"),e("code",[t._v("Ownable")]),t._v("标准实现如下：\n"),e("a",{attrs:{href:"https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol"),e("OutboundLink")],1)]),t._v(" "),e("h2",{attrs:{id:"remix-演示示例"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#remix-演示示例"}},[t._v("#")]),t._v(" Remix 演示示例")]),t._v(" "),e("p",[t._v("以 "),e("code",[t._v("Owner.sol")]),t._v(" 为例。")]),t._v(" "),e("ol",[e("li",[t._v("在 Remix 上编译部署代码。")]),t._v(" "),e("li",[t._v("点击 "),e("code",[t._v("owner")]),t._v(" 按钮查看当前 owner 变量。\n"),e("img",{attrs:{src:"img/11-1.jpg",alt:""}})]),t._v(" "),e("li",[t._v("以 owner 地址的用户身份，调用 "),e("code",[t._v("changeOwner")]),t._v(" 函数，交易成功。\n"),e("img",{attrs:{src:"img/11-2.jpg",alt:""}})]),t._v(" "),e("li",[t._v("以非 owner 地址的用户身份，调用 "),e("code",[t._v("changeOwner")]),t._v(" 函数，交易失败，因为modifier onlyOwner 的检查语句不满足。\n"),e("img",{attrs:{src:"img/11-3.jpg",alt:""}})])]),t._v(" "),e("h2",{attrs:{id:"总结"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),e("p",[t._v("这一讲，我们介绍了"),e("code",[t._v("solidity")]),t._v("中的构造函数和修饰符，并举了一个控制合约权限的"),e("code",[t._v("Ownable")]),t._v("合约。")])])}),[],!1,null,null,null);s.default=n.exports}}]);